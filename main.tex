\documentclass[12pt,a4paper]{article}

% Seitenränder
\usepackage[a4paper,margin=3cm]{geometry}

% Serifen-Schriftart (Times)
\usepackage{mathptmx}

% Zeilenabstand
\usepackage{setspace}
\singlespacing  % einfacher Zeilenabstand

% Deutsche Sprache + Umlaute
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{fancyvrb}
\usepackage{csquotes}


% Seitenzahlen
\pagestyle{plain}

% Literatur
% \usepackage[backend=biber,style=alphabetic,heading=none]{biblatex}
\usepackage[backend=biber,style=alphabetic,language=ngerman, sorting=nyt]{biblatex}
% \usepackage[backend=biber,style=alphabetic]{biblatex}
\addbibresource{literatur.bib}

% Titelinformationen
\title{Vergleich von CLP(FD) in SWI-Prolog und dem CP-SAT-Solver von Google OR-Tools}
\author{Jonas Lorenz\\Matrikelnummer: 741255\\Studiengang: Bachelor Informatik}
\date{\today}

\begin{document}

\maketitle
\thispagestyle{empty}

\newpage

\tableofcontents
\thispagestyle{empty}
\newpage


\section{Einleitung}
\label{sec:einleitung}
Constraint-Programmierung und -Solving sind zentrale Lösungsansätze für zahlreiche Kombinatorik- und Optimierungsprobleme in Industrie und Forschung.
Dazu zählen beispielsweise Anwendungen im Bereich der künstlichen Intelligenz \cite{popescu2022} sowie in der Planung industrieller Abläufe \cite{clp_book}.

Anders als beim klassischen imperativen Programmieren, bei dem die Lösung eines Problems sequentiell beschrieben wird, formuliert die Constraint-Programmierung ausschließlich die Bedingungen, die eine Lösung erfüllen muss.
Es handelt sich somit um einen deklarativen Ansatz; die konkrete Belegung der Variablen wird anschließend von einem Constraint-Solver ermittelt.

Das CLP(FD)-Modul in der deklarativen Sprache SWI-Prolog sowie der CP-SAT-Solver aus der Google-OR-Tools-Bibliothek sind zwei unterschiedliche Implementierungen der ganzzahligen Constraint-Programmierung.
Obwohl OR-Tools eine Vielzahl weiterer -- sowohl kommerzieller als auch Open-Source -- Solver unterstützt, wird in dieser Arbeit CP-SAT betrachtet.
CP-SAT gilt als leistungsstärkster Bestandteil der OR-Tools-Bibliothek und erzielte unter anderem bei der MiniZinc Challenge 2024 \cite{minizinc2024,perron} in allen Kategorien den ersten Platz.

Ziel der Arbeit ist es, die beiden genannten Constraint-Systeme kompakt zu präsentieren und sie hinsichtlich ihrer Such- und Propagationsverfahren, der internen Modellverarbeitung, ihres Monotonie-Verhaltens zu vergleichen.
Desweiteren erfolgt ebenfalls ein praktischer Vergleich der Constraint-Solver mittels eines Benchmarks unter Verwendung des N-Queens-Problems \cite{nqueens} und dem Seven-Eleven-Problems \cite{seven_eleven}. 

\section{Grundlagen und verwandte Arbeiten}
\subsection{Constraints und Constraint-Programmierung}
Das englische Wort \glqq Constraint\grqq{} lässt sich mit Einschränkung oder Nebenbedingung übersetzen.
In der Informatik beschreibt es eine Bedingung, die jede gültige Lösung eines Problems erfüllen muss.
Constraints eignen sich allgemein gut, um unvollständige Informationen darzustellen.
Sie ermöglichen es, die Eigenschaften und Beziehungen von Objekten zu beschreiben, auch wenn diese nur teilweise bekannt sind \cite{clp_book}.

Wie bereits in Abschnitt \ref{sec:einleitung} beschrieben, verfolgt die Constraint-Programmierung einen deklarativen Ansatz.
Dabei wird ein Problem modelliert, indem folgende, elementare Bestandteile beschrieben werden: die Variablen, deren Wertebereiche sowohl vordefinierte als auch benutzerdefinierte Constraints, die die Variablen zueinander in Beziehung setzen und den Lösungsraum einschränken.

Ein modelliertes Problem wird anschließend durch einen Constraint-Solver gelöst.
Dabei handelt es sich um eine spezielle Softwarekomponente, die die Erfüllbarkeit eines Constraint-Problems prüft und konkrete Lösungen für eben dieses berechnen kann \cite{drt,clp_book2}.

\noindent
Das Vorgehen eines klassischen Constraint-Solvers besteht aus drei grundlegenden Schritten:
\begin{enumerate}
    \item Festlegen einer Variable durch Auswahl und Zuweisung eines Werts aus ihrem aktuellen Wertebereich,
    \item Propagation der Konsequenzen dieser Festlegung auf die übrigen Variablen,
    \item Fortsetzen mit der nächsten Variable oder -- bei Inkonsistenz -- Rücksprung zu einer vorherigen Entscheidung (Backtracking siehe \ref{sec:backtracking}) und Wahl einer alternativen Belegung.
\end{enumerate}
Dieser Vorgang erfolgt so lang rekursiv, bis entweder eine gültige Lösung oder aber keine Lösung gefunden wurde \cite{clp_book2}.
\subsection{Zentrale Mechanismen und Eigenschaften}
In diesem Abschnitt werden zentrale Mechanismen und Eigenschaften vorgestellt, welche von Constraint-Solvern angewandt werden, um beschriebene Probleme systematisch zu lösen. 
Die konkrete Ausprägung von eben diesen ist abhängig vom jeweiligen Solver.
\subsubsection{Propagation}
Propagation bezeichnet die Ableitung logischer Konsequenzen aus bestehenden Constraints und den aktuellen Wertebereichen der Variablen \cite{clp92}.
Es geht im Kern darum, inkonsistente Werte aus den jeweiligen Wertebereichen zu entfernen.
Als \glqq inkonsistent\grqq{} wird in diesem Kontext eine Belegung für eine Variable beschrieben, mit welcher ein Constraint (oder mehrere) nicht mehr erfüllt werden kann.

Constraint-Systeme nutzen hierzu Propagatoren, die auf Änderungen in den Wertebereichen reagieren und ggf. diese inkonsistenten Werte entfernen.
Dieser Vorgang wird wiederholt, bis ein stabiler Zustand (Fixpunkt) erreicht ist, bei dem keine weitere Reduzierung möglich ist \cite{clp_handbook}.
\subsubsection{Backtracking}
\label{sec:backtracking}
Getroffene Variablenbelegungen sowie die daraus resultierenden Propagationen lassen sich durch einen Entscheidungsbaum darstellen.
Stellt der Solver während der Expansion des Baumes einen Konflikt mit anderen Constraints fest, dann wird im Entscheidungsbaum zum vorherigen Entscheidungsknoten zurückgesprungen und trifft -- wenn möglich -- eine andere Wahl.
Dieser Prozess wird als Backtracking bezeichnet \cite{clp_handbook}. 
Sollte keine weitere Alternative zur Verfügung stehen, dann wird das Prüfen auf Alternativen und eventuelles Zurücksetzen rekursiv fortgeführt, potentiell bis zur Wurzel.
Dort endet die Suche.

Wird der Entscheidungsbaum während des Backtrackings vollständig expandiert, dann gibt es keine Lösung für das modellierte Problem \cite{clp_book2}.
\subsubsection{Monotonie}
Ein Constraint-System heißt monoton, wenn das Hinzufügen weiterer Constraints keine neuen Lösungen erzeugt \cite{drt}\cite{swi-clpfd-doc}.
In nicht-monotonen Systemen kann die Reihenfolge der Constraint-Angaben zu unterschiedlichen Ergebnissen führen, wie Triska \cite[S. 37]{drt} anhand zweier identischer, lediglich in der Reihenfolge variierender Anfragen zeigt.

Für das Constraint-System selbst stellt nicht-monotones Verhalten kein Problem dar, es kann jedoch die Fehlersuche im Entwicklungsprozess erschweren.

Zur Lösung des Problems existieren unterschiedliche Ansätze: Eine Möglichkeit besteht darin, Monotonie syntaktisch zu erzwingen, was zwar die Modellierung etwas einschränkt, jedoch konsistente Ergebnisse gewährleistet.
Alternativ setzen einige Solver-Architekturen bereits von Grund auf auf ein monotones Modell, wodurch die Eigenschaft inhärent gegeben ist.
Konkrete Ausprägungen dieser Ansätze werden in Abschnitt \ref{sec:monotonie} im Rahmen des Vergleichs erläutert.
\subsection{CLP(FD) in SWI-Prolog}
\label{sec:clpfd}
Die folgenden Erläuterungen stützen sich auf die Dissertation \cite{drt} sowie einen Artikel \cite{clpfd} von Markus Triska, in denen zentrale Eigenschaften und Designentscheidungen der CLP(FD)-Bibliothek dargestellt werden.

CLP(FD) -- kurz für \emph{Constraint Logic Programming over Finite Domains} -- ist eine von Markus Triska im Rahmen seiner Promotion entwickelte Bibliothek für die deklarative Programmiersprache SWI-Prolog und Teil der Standardinstallation. 
Sie ermöglicht die Modellierung und Lösung kombinatorischer Probleme, die durch ganzzahlige Variablen mit endlichem Wertebereich beschrieben werden können.

Der allgemeine Ablauf zur Lösung eines Constraint-Problems mit CLP(FD) besteht aus drei Komponenten:
\begin{enumerate}
    \item Deklarierung der Variablen und initiale Angabe deren Wertebereiche mit \texttt{ins/2}.
    \item Definierung der Constraints durch arithmetische Operationen (z.B. \texttt{\#=, \#\textbackslash=, \#<}) oder globalen Constraints wie \texttt{all\_distinct}.
    \item Starten der Lösungssuche mit \texttt{label/1} oder \texttt{labeling/2}. Hierbei kommen Labeling, Propagation und Backtracking zum Einsatz.
\end{enumerate}

\noindent
Um das Vorgehen zu veranschaulichen folgt ein einfaches Beispiel zur Constraint-Lösung mit CLP(FD):

\begin{Verbatim}[numbers=left, xleftmargin=5mm, frame=lines]
    ?- use_module(library(clpfd)),
       [X, Y, Z] ins 1..10,
       X #< Y, Y #< Z,
       X + Y + Z #= 15,
       label([X, Y, Z]).
\end{Verbatim}

\noindent
Die Zeilen zwei bis vier entsprechen den ersten beiden Schritten: Variablen deklarieren und Constraints setzen.
In Zeile 5 wird mit \texttt{label/1} die Suche gestartet. 

Das Suchen nach einer Lösung für das modellierte Problem wird vom Constraint-Solver von CLP(FD) durchgeführt.
Dabei ist die garantierte Terminierung der Propagation eine zentrale Eigenschaft, da SWI-Prolog Variablen mit unendlichem Wertebereich unterstützt.
Ohne Einschränkung könnte eine Propagation in diesem Fall nie terminieren, da eine Schranke einer unendlichen Variablen beliebig oft erhöht oder verringert werden kann.
Um dies zu verhindern, dürfen die Schranken sowie deren Spanne bei einer unendlichen Variablen nur einmal verändert werden.
Dadurch kann keine Endlosschleife entstehen, in der der Solver unendlich lang die Schranken verändert, ohne Fortschritt in der Propagation zu erzielen.

Beim Lösen von Constraint-Problemen können mitunter sehr große Zwischenergebnisse auftreten, die in einigen Systemen zu Überläufen führen.
CLP(FD) in SWI-Prolog unterstützt daher beliebig große Ganzzahlen und kann mit unendlichen Wertebereichen arbeiten.
Dies erweitert den Anwendungsbereich, da sich auch Probleme mit natürlich großen oder theoretisch unendlichen Domänen modellieren lassen, ohne auf spezielle Arithmetik ausweichen zu müssen.
Insbesondere auf 32-bit-Systemen ist diese Eigenschaft von Vorteil, da dort Überläufe deutlich schneller auftreten als auf moderneren 64-bit-Systemen.

Während die garantierte Terminierung eine Eigenschaft des Constraint-Solvers ist, betreffen die Unterstützung beliebig großer Ganzzahlen sowie die Möglichkeit Monotonie syntaktisch zu erzwingen die gesamte CLP(FD)-Bibliothek.

\subsection{Google OR-Tools und der CP-SAT-Solver}
\label{sec:ortools}
Die Google-OR-Tools-Bibliothek, \glqq OR\grqq{} kurz für \emph{Operations Research}, ist in C++ implementiert und bietet offizielle Schnittstellen unter anderem für Python und Java.
In dieser Arbeit wird sie ausschließlich über Python angesprochen.
Zur Verwendung muss die Bibliothek zunächst installiert werden (beispielsweise über den Python-Paketmanager \texttt{pip}).

Constraint-Probleme können in OR-Tools allgemein über ganzzahlige Variablen mit endlichen Wertebereichen modelliert werden.
Der grundlegende Modellierungsablauf ist analog zu CLP(FD):

\begin{enumerate}
    \item Deklaration der Variablen und ihrer Wertebereiche mit \texttt{NewIntVar}.
    \item Festlegen der Constraints: allgemeine boolesche Constraints über \texttt{Add}, globale Constraints wie \texttt{AllDifferent} über spezialisierte Methoden.
    \item Starten der Suche mit \texttt{CpSolver().Solve(model)}.
\end{enumerate}

\noindent
Zur Demonstration folgt dasselbe Modell wie in Abschnitt \ref{sec:clpfd}:

\begin{Verbatim}[numbers=left, xleftmargin=5mm, frame=lines]
    from ortools.sat.python import cp_model as cp
    m = cp.CpModel()
    X = m.NewIntVar(1, 10, "X")
    Y = m.NewIntVar(1, 10, "Y")
    Z = m.NewIntVar(1, 10, "Z")
    m.Add(X < Y)
    m.Add(Y < Z)
    m.Add(X + Y + Z == 15)
    s = cp.CpSolver()
    s.Solve(m)
\end{Verbatim}

Die grundlegende Architektur des Solvers ist ein hybrider Portfolio-Ansatz, das heißt es werden mehrere unterschiedliche Heuristiken sowie Suchverfahren parallel mittels mehrerer Threads ausgeführt \cite{perron}.
Dazu gehören klassische Constraint-Propagation, Techniken aus dem SAT-Solving und Methoden der linearen Optimierung \cite{cp-sat-primer}.
Während der Laufzeit tauschen die Threads (In OR-Tools-Terminologie \glqq workers\grqq{}) kontinuierlich gewonnene Informationen -- dazu gehören beispielsweise bessere engere Wertebereichsgrenzen oder gefundene Teillösungen -- aus.
Heuristiken sind dabei zum Beispiel das regelmäßige Neustarten der Suche oder Abbruch nach einer gewissen Anzahl an Konflikten.

\subsection{Verwandte Arbeiten}
Marten \cite{marten2018} vergleicht drei verschiedene Arten von Constraint-Solvern – CSP-, SAT- und BDD-basierte Ansätze – anhand künstlich erzeugter Modelle.
Für die Tests werden die Modellparameter systematisch variiert, so zum Beispiel die Anzahl der Variablen, deren Struktur und die Anzahl zusätzlicher Nebenbedingungen.
Die Ergebnisse werden anschließend mit realen Beispielen validiert.
Die Arbeit zeigt, dass BDD-Ansätze bei der Zählung möglicher Konfigurationen oft am effizientesten sind, während CSP- und SAT-Solver je nach Modellstruktur ähnliche Leistungen erbringen.\\
\\
In Bauer \cite{bauer2019} werden sechs gängige Constraint-Solver im Rahmen der Variabilitätsanalyse von Feature-Modellen verglichen.
Dafür werden künstliche und reale Modelle kombiniert, um sowohl die Rechenzeit als auch die Vielfalt (Repräsentativität) der gefundenen Lösungen zu bewerten.
Aus den Ergebnissen leitet die Arbeit praxisorientierte Empfehlungen ab, welcher Solver – je nach Anwendungsschwerpunkt – am besten geeignet ist.\\
\\
Triska \cite{drt} präsentiert neben den theoretischen Grundlagen und Eigenschaften von CLP(FD) auch Benchmark-Ergebnisse von Neng-Fa Zhou, dem Entwickler von B-Prolog, für verschiedene Prolog-Systeme.
Das genaue Testdesign dieser Messungen wird nicht beschrieben.
Die Resultate zeigen, dass CLP(FD) in Kombination mit SWI-Prolog im Vergleich eine geringere Ausführungsgeschwindigkeit aufweist und daher für viele industrielle Anwendungen weniger geeignet ist.
Aufgrund seiner Eigenschaften wird es jedoch weiterhin für Lehr- und Forschungszwecke eingesetzt.
Zudem ist CLP(FD) der einzige getestete Solver, der beliebig große Ganzzahlen unterstützt. 
\section{Vergleich von CLP(FD) und CP-SAT}
\subsection{Interne Modellverarbeitung}
Variablen werden in CLP(FD) als \emph{attributed variables} gespeichert.
Dies umfasst den aktuellen Wertebereich, sowie alle Propagatoren, die bei einer Änderung an der Variable überprüft werden müssen.
Zusätzlich speichern attributed variables -- wenn die Variable noch unendlich ist -- ob eine Schranke oder die Spanne des Wertebereichs geändert wurde.



\subsection{Suchverfahren und Propagation}
\label{sec:search_prop}
CLP(FD) in SWI-Prolog verwendet ein klassisches, sequentielles Suchverfahren.
Dabei werden Variablen in einer vom Anwender wählbaren oder durch Heuristiken bestimmten Reihenfolge belegt (\emph{Labeling}).
Jede Belegung wird unmittelbar durch Constraint-Propagation überprüft.
Als Konsistenzniveau wird dabei \emph{Domain Consistency} angestrebt, d.\,h. für jede Variable wird sichergestellt, dass jeder verbleibende Wert mit allen Constraints vereinbar ist.
Tritt eine Inkonsistenz auf, greift der Solver auf Backtracking zurück, um alternative Belegungen zu prüfen.
Die Suche erfolgt grundsätzlich in einem einzelnen Thread.

Der CP-SAT-Solver aus Google OR-Tools verfolgt hingegen einen hybriden Portfolio-Ansatz.
Mehrere Suchstrategien und Heuristiken werden parallel in separaten Threads (workers) ausgeführt \cite{perron}.
Neben klassischer Constraint-Propagation kommen Techniken aus dem SAT-Solving zum Einsatz, darunter Konfliktanalyse mit \emph{Conflict-Driven Clause Learning} (CDCL) und Lazy Clause Generation.
Diese Verfahren ermöglichen es, aus Konflikten während der Suche neue Klauseln abzuleiten, die den Suchraum dauerhaft einschränken.
Informationen wie engere Wertebereichsgrenzen oder Teillösungen werden zwischen den Threads kontinuierlich ausgetauscht, wodurch unterschiedliche Suchstränge voneinander profitieren können. 

Während CLP(FD) inkrementell arbeitet und jede Entscheidung unmittelbar propagiert, formuliert CP-SAT das Modell in eine erweiterte SAT-Form um und kombiniert diese mit Ganzzahlarithmetik.
Die Propagation orientiert sich dabei an \emph{Bound Consistency} und SAT-Klauselpropagation, wodurch sich in vielen Fällen eine schnellere Eingrenzung des Suchraums ergibt.
\subsection{Monotonie}
\label{sec:monotonie}

In SWI-Prolog CLP(FD) kann Monotonie über die Prolog-Flag \texttt{clpfd\_monotonic} aktiviert werden.  
In diesem Modus ist der Operator \texttt{?/1} verpflichtend, um Variablen explizit als ganze Zahlen zu kennzeichnen.
Zusammengesetzte arithmetische Terme (z.\,B. \texttt{(1+1)}) werden abgelehnt.
Auch ist \texttt{X \#=3 } dann nicht mehr zulässig, weil zu wenig über die Variable \texttt{X} bekannt ist.   
Dadurch können durch unterschiedliche Auswertungsreihenfolgen keine neuen Lösungen entstehen \cite{swi-clpfd-doc}.
\subsection{Benchmark}
\label{sec:performance}
\section{Zusammenfassung}
\section{Literaturverzeichnis}
\renewcommand*{\bibname}{} % für Bücher (report, book, etc.)
\renewcommand*{\refname}{} % für Artikel (article-Klasse)
\printbibliography
\end{document}
